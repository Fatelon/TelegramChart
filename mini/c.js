class Point{constructor(t,i){this.x=t,this.y=i}}class Pair{constructor(t,i){this.left=t,this.right=i}}class Interval{constructor(t,i,e){this.left=t,this.right=i,this.step=e}isEqual(t){return this.left===t.left&&this.right===t.right&&this.step===t.step}}class Boundaries{constructor(t,i,e,a){this.top=t,this.right=i,this.bottom=e,this.left=a}getPair(t){return t?new Pair(this.left,this.right):new Pair(this.bottom,this.top)}}class Utils{static getMiddleInterval(t,i,e){return new Interval(t.left+(i.left-t.left)*e,t.right+(i.right-t.right)*e,t.step+(i.step-t.step)*e)}static getYBorderPair(t){const i=new Pair(Number.MAX_VALUE,Number.MIN_VALUE);return t.forEach(t=>{i.left=Math.min(Math.min(...t),i.left);i.right=Math.max(Math.max(...t),i.right)}),i}static getLimits(t,i,e){const a=new Boundaries(Number.MIN_VALUE,Math.max(...t),Number.MAX_VALUE,Math.min(...t));return i.forEach((t,i)=>{e[Utils.getKeys(e)[i]]&&(a.bottom=Math.min(Math.min(...t),a.bottom),a.top=Math.max(Math.max(...t),a.top))}),a.bottom===Number.MAX_VALUE&&(a.bottom=Math.min(...i[0])),a.top===Number.MIN_VALUE&&(a.top=Math.max(...i[0])),a}static calculateCanvasBoundaries(t,i,e){return new Boundaries(i-e.top,t-e.right,e.bottom,e.left)}static drawChartLine(t,i,e,a,s,n){t.lineWidth=s,t.lineCap="round",t.strokeStyle=a,t.beginPath(),i.forEach((i,a)=>{e.length>a&&t.lineTo(i,e[a])}),t.stroke(),null!==n&&(t.beginPath(),t.fillStyle="#FFFFFF",t.arc(i[n],e[n],5,0,2*Math.PI),t.fill(),t.arc(i[n],e[n],5,0,2*Math.PI),t.stroke())}static formatDate(t){const i=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],e=t.getDate();return i[t.getMonth()]+" "+e}static getScale(t,i){return Math.abs(i.right-i.left)/Math.abs(t.right-t.left)}static getKeys(t){return Object.keys(t)}static isPointInFrame(t,i){return!(t.x<i.left||t.x>i.right||t.y<i.bottom||t.y>i.top)}static getInterval(t,i){const e=(t.right-t.left)/Math.pow(10,6);t.right+=e,t.left-=e;const a=(t.right-t.left)/(i-1),s=[1,1.5,2,2.5,5,7.5,10],n=Math.pow(10,-Math.floor(Math.log10(Math.abs(a)))),h=a*n,r=s.find(t=>t>=h),o=Number.parseInt((r/n).toFixed()),l=Math.ceil(t.right/o)*o,c=Math.floor(t.left/o)*o;return new Interval(c,l,o)}}class TelegramChart{constructor(t){this.init(t)}init(t){this.canvasContext=null,this.canvas=null,this.width=2*window.innerWidth/3,this.height=2*window.innerHeight/3,this.xData=[],this.yAllData=[],this.limitedData=new Point([],[]),this.linesColors=[],this.yIds={},this.lablesNumber=new Point(7,7),this.yPredInterval=new Interval(0,0,1),this.yNewInterval=new Interval(0,0,1),this.axeBoundInterval=new Point(new Interval(0,0,1),new Interval(0,0,1)),this.currentScale=new Point(1,1),this.animationFactor=new Point(1,1),this.currentAnimation=null,this.frameDragType="",this.changeFrameAllowed=!1,this.minFrameWidth=this.width/100,this.predMousePoint=new Point(0,0),this.canvasMargin=new Boundaries(50,0,0,0),this.fBorderWidth=new Point(this.width/100,this.height/250),this.setColors(!1),this.initCanvas(),this.prepareData(t),this.refreshView(!0)}initCanvas(){this.canvas=document.createElement("canvas"),document.getElementById("cc").appendChild(this.canvas),this.canvas.onmouseup=this.onMouseUp.bind(this),this.canvas.onmousedown=this.onMouseDown.bind(this),this.canvas.onmousemove=this.onMouseMove.bind(this),this.canvas.onmouseleave=this.onMouseLeave.bind(this),this.addMobile(),this.canvas.width=this.width,this.canvas.height=this.height,this.canvasContext=this.canvas.getContext("2d"),this.canvasContext.transform(1,0,0,-1,0,this.canvas.height);const t=.15*this.canvas.height;this.bigChartBoundaries=new Boundaries(this.canvas.height-this.canvasMargin.top,this.canvas.width-this.canvasMargin.right,this.canvasMargin.bottom+t+30,this.canvasMargin.left),this.smallChartBoundaries=new Boundaries(t+this.canvasMargin.bottom,this.canvas.width-this.canvasMargin.right,this.canvasMargin.bottom,this.canvasMargin.left),this.smallChartWidth=this.smallChartBoundaries.right-this.smallChartBoundaries.left,this.frameBoundaries=new Boundaries(this.smallChartBoundaries.top,this.smallChartBoundaries.left+.2*this.canvas.width,this.smallChartBoundaries.bottom,this.smallChartBoundaries.left)}prepareData(t){t.columns.forEach(i=>{const e=i.slice(0,1);const a=i.slice(1);"x"===t.types[e]?this.xData=a:"line"===t.types[e]&&(this.yIds[e]=!0,this.yAllData.push(a),this.linesColors.push(t.colors[e]))})}refreshView(t){t&&this.calculateDataAndBoundaries(),this.canvasContext.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawBigChart(),this.drawSmallChart()}calculateDataAndBoundaries(){const t=new Pair(this.frameBoundaries.left/this.smallChartWidth,this.frameBoundaries.right/this.smallChartWidth),i=this.xData[this.xData.length-1]-this.xData[0];this.axeBoundInterval.x.left=i*t.left+this.xData[0],this.axeBoundInterval.x.right=i*t.right+this.xData[0];let e=0,a=0;for(this.xData.forEach((t,i)=>{t<this.axeBoundInterval.x.left?e=i+1:t>this.axeBoundInterval.x.right||(a=i)});Math.ceil((a-e+1)/this.axeBoundInterval.x.step)>9;)this.axeBoundInterval.x.step*=2;for(;5>Math.ceil((a-e+1)/this.axeBoundInterval.x.step);)this.axeBoundInterval.x.step/=2;e=Math.max(e-1,0),a=Math.min(a+1,this.xData.length-1)+1,this.limitedData.x=this.xData.slice(e,a),this.limitedData.y=[],this.yAllData.forEach((t,i)=>{this.yIds[Utils.getKeys(this.yIds)[i]]&&this.limitedData.y.push(t.slice(e,a))}),this.currentScale.x=Utils.getScale(this.axeBoundInterval.x,this.bigChartBoundaries.getPair(!0));const s=Utils.getInterval(Utils.getYBorderPair(this.limitedData.y),this.lablesNumber.y);s.isEqual(this.yPredInterval)||s.isEqual(this.yNewInterval)?this.refreshView(!1):(null!==this.currentAnimation&&(clearTimeout(this.currentAnimation),console.log("CANCELED!!!")),this.axeBoundInterval.y=s,this.yNewInterval=s,console.log("GO ANIMATION"),this.runAnimation(0,this))}runAnimation(t,i){(t+=.06)>1?(i.yCalculateMiddleIntervalAndRefrash(1),clearTimeout(i.currentAnimation),i.currentAnimation=null):(i.yCalculateMiddleIntervalAndRefrash(t),i.currentAnimation=setTimeout(i.runAnimation,15,t,i))}yCalculateMiddleIntervalAndRefrash(t){1===t?(this.yPredInterval=this.yNewInterval,this.axeBoundInterval.y=this.yNewInterval):this.axeBoundInterval.y=Utils.getMiddleInterval(this.yPredInterval,this.yNewInterval,t),this.animationFactor.y=t,this.currentScale.y=Utils.getScale(this.axeBoundInterval.y,this.bigChartBoundaries.getPair(!1)),this.refreshView(!1)}drawBigChart(){1!==this.animationFactor.y&&this.drawHorizontalLines(this.yPredInterval,1-this.animationFactor.y),this.drawHorizontalLines(this.yNewInterval,this.animationFactor.y);const t=this.limitedData.x.map(t=>(t-this.axeBoundInterval.x.left)*this.currentScale.x+this.bigChartBoundaries.left),i=this.drawVerticalLine(t);this.limitedData.y.forEach((e,a)=>{Utils.drawChartLine(this.canvasContext,t,e.map(t=>(t-this.axeBoundInterval.y.left)*this.currentScale.y+this.bigChartBoundaries.bottom),this.linesColors[a],3,i)}),1!==this.animationFactor.y&&this.drawYScaleLabelsText(this.yPredInterval,1-this.animationFactor.y),this.drawYScaleLabelsText(this.yNewInterval,this.animationFactor.y),this.drawXScaleLabelsText()}drawHorizontalLines(t,i){this.canvasContext.beginPath(),this.canvasContext.strokeStyle="rgba(223, 230, 235, "+i+")",this.canvasContext.lineWidth=1;let e=0;for(;e<=t.right-t.left&&t.step>0;){const i=e*this.currentScale.y+this.bigChartBoundaries.bottom;this.canvasContext.moveTo(this.bigChartBoundaries.left,i),this.canvasContext.lineTo(this.bigChartBoundaries.right,i),e+=t.step}this.canvasContext.stroke()}drawVerticalLine(t){if(Utils.isPointInFrame(this.predMousePoint,this.bigChartBoundaries)){let i=0;for(;Math.abs(t[i+1]-this.predMousePoint.x)<Math.abs(t[i]-this.predMousePoint.x)||this.bigChartBoundaries.left>t[i]&&this.bigChartBoundaries.right>=t[i];)i++;return this.canvasContext.beginPath(),this.canvasContext.strokeStyle="#B6C2CA",this.canvasContext.lineWidth=1,this.canvasContext.moveTo(t[i],this.bigChartBoundaries.top),this.canvasContext.lineTo(t[i],this.bigChartBoundaries.bottom),this.canvasContext.stroke(),i}}drawYScaleLabelsText(t,i){const e=this.canvas.height;this.canvasContext.transform(1,0,0,-1,0,e),this.canvasContext.fillStyle="rgba(150, 162, 170, "+i+")",this.canvasContext.font=this.labelsTextFont;let a=0;for(;a<=t.right-t.left&&t.step>0;){const i=a*this.currentScale.y+this.bigChartBoundaries.bottom;this.canvasContext.fillText(""+(t.left+a),this.bigChartBoundaries.left,e-i-.015*e),a+=t.step}this.canvasContext.transform(1,0,0,-1,0,e)}drawXScaleLabelsText(){const t=this.canvas.height;this.canvasContext.transform(1,0,0,-1,0,t),this.canvasContext.fillStyle="rgba(150, 162, 170, 1)";for(let i=0;i<=this.xData.length;i+=this.axeBoundInterval.x.step){this.canvasContext.fillStyle="rgba(150, 162, 170, 1)";const e=this.xData[i],a=(e-this.axeBoundInterval.x.left)*this.currentScale.x+this.bigChartBoundaries.left;this.canvasContext.fillText(""+Utils.formatDate(new Date(e)),a,t-this.bigChartBoundaries.bottom+20)}this.canvasContext.transform(1,0,0,-1,0,t)}drawSmallChart(){const t=this.smallChartBoundaries.bottom+5,i=Utils.getYBorderPair(this.yAllData,this.yIds),e=Utils.getScale(i,new Pair(t,this.smallChartBoundaries.top-5)),a=Utils.getScale(new Pair(this.xData[0],this.xData[this.xData.length-1]),this.smallChartBoundaries),s=this.xData.map(t=>(t-this.xData[0])*a+this.smallChartBoundaries.left);this.yAllData.forEach((a,n)=>{this.yIds[Utils.getKeys(this.yIds)[n]]&&Utils.drawChartLine(this.canvasContext,s,a.map(a=>(a-i.left)*e+t),this.linesColors[n],1,null)}),this.drawFrame()}drawFrame(){const t=this.fBorderWidth.x,i=this.fBorderWidth.y;this.canvasContext.strokeStyle=this._frameColor,this.canvasContext.beginPath(),this.canvasContext.lineCap="butt",this.canvasContext.lineWidth=i,this.canvasContext.moveTo(this.frameBoundaries.left,this.frameBoundaries.top-i/2),this.canvasContext.lineTo(this.frameBoundaries.right,this.frameBoundaries.top-i/2),this.canvasContext.moveTo(this.frameBoundaries.right,this.frameBoundaries.bottom+i/2),this.canvasContext.lineTo(this.frameBoundaries.left,this.frameBoundaries.bottom+i/2),this.canvasContext.stroke(),this.canvasContext.beginPath(),this.canvasContext.lineWidth=t,this.canvasContext.moveTo(this.frameBoundaries.left+t/2,this.frameBoundaries.bottom+i),this.canvasContext.lineTo(this.frameBoundaries.left+t/2,this.frameBoundaries.top-i),this.canvasContext.moveTo(this.frameBoundaries.right-t/2,this.frameBoundaries.top-i),this.canvasContext.lineTo(this.frameBoundaries.right-t/2,this.frameBoundaries.bottom+i),this.canvasContext.stroke(),this.canvasContext.fillStyle=this._outFrameColor,this.canvasContext.fillRect(this.smallChartBoundaries.left,this.smallChartBoundaries.bottom,this.frameBoundaries.left-this.smallChartBoundaries.left,this.frameBoundaries.top-this.smallChartBoundaries.bottom),this.canvasContext.fillRect(this.frameBoundaries.right,this.frameBoundaries.bottom,this.smallChartBoundaries.right-this.frameBoundaries.right,this.frameBoundaries.top-this.smallChartBoundaries.bottom)}setColors(t){this.labelsTextFont="lighter 9pt Helvetica",this._frameColor="rgba(221, 234, 243, 0.7)",this._outFrameColor="rgba(245, 249, 251, 0.7)"}onMouseUp(t){this.changeFrameAllowed=!1}onMouseDown(t){const i=t.target.getBoundingClientRect(),e=new Point(t.clientX-i.left,i.bottom-t.clientY);Utils.isPointInFrame(e,this.smallChartBoundaries)?(this.changeFrameAllowed=!0,this.predMousePoint=e,e.x<this.frameBoundaries.left+this.fBorderWidth.x?this.frameDragType="left":e.x>this.frameBoundaries.right-this.fBorderWidth.x?this.frameDragType="right":this.frameDragType="center"):this.changeFrameAllowed=!1}onMouseMove(t){const i=t.target.getBoundingClientRect(),e=new Point(t.clientX-i.left,i.bottom-t.clientY);if(e.x!==this.predMousePoint.x){if(Utils.isPointInFrame(e,this.smallChartBoundaries)||(this.changeFrameAllowed=!1),this.changeFrameAllowed){const t=e.x-this.predMousePoint.x;if("left"===this.frameDragType){const i=Math.min(this.frameBoundaries.left+t,this.frameBoundaries.right-2*this.fBorderWidth.x-this.minFrameWidth);this.frameBoundaries.left=Math.max(this.smallChartBoundaries.left,i)}else if("right"===this.frameDragType){const i=Math.max(this.frameBoundaries.right+t,this.frameBoundaries.left+2*this.fBorderWidth.x+this.minFrameWidth);this.frameBoundaries.right=Math.min(this.smallChartBoundaries.right,i)}else"center"===this.frameDragType&&(this.frameBoundaries.left+t<this.smallChartBoundaries.left||this.frameBoundaries.right+t>this.smallChartBoundaries.right||(this.frameBoundaries.left+=t,this.frameBoundaries.right+=t))}this.predMousePoint=e,this.refreshView(this.changeFrameAllowed)}}onMouseLeave(t){this.changeFrameAllowed=!1,this.refreshView(!1)}addMobile(){this.canvas.addEventListener("touchstart",function(t){const i=t.touches[0];this.canvas.dispatchEvent(new MouseEvent("mousedown",{clientX:i.clientX,clientY:i.clientY}))}.bind(this)),this.canvas.addEventListener("touchend",function(t){this.canvas.dispatchEvent(new MouseEvent("mouseup",{}))}.bind(this)),this.canvas.addEventListener("touchmove",function(t){this.canvas.dispatchEvent(new MouseEvent("mousemove",{clientX:t.touches[0].clientX,clientY:t.touches[0].clientY}))}.bind(this))}}let jsonData=[];const xhr=new XMLHttpRequest;xhr.open("GET","/chart_data.json"),xhr.onreadystatechange=(t=>{xhr.readyState===XMLHttpRequest.DONE&&200===xhr.status&&(jsonData=JSON.parse(xhr.responseText)).forEach(t=>new TelegramChart(t))}),xhr.send(),resize=(()=>{const t=document.getElementById("cc");for(;t.firstChild;)t.removeChild(t.firstChild);jsonData.forEach(t=>new TelegramChart(t))}),window.addEventListener("resize",resize);