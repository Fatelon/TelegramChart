class Point{constructor(t,n){this.x=t,this.y=n}}class Pair{constructor(t,n){this.left=t,this.right=n}}class Interval{constructor(t,n,i){this.left=t,this.right=n,this.step=i}isEqual(t){return this.left===t.left&&this.right===t.right&&this.step===t.step}}class Boundaries{constructor(t,n,i,e){this.top=t,this.right=n,this.bottom=i,this.left=e}getPair(t){return t?new Pair(this.left,this.right):new Pair(this.bottom,this.top)}}class Utils{static getMiddleInterval(t,n,i){return new Interval(t.left+(n.left-t.left)*i,t.right+(n.right-t.right)*i,t.step+(n.step-t.step)*i)}static getYBorderPair(t,n){const i=new Pair(Number.MAX_VALUE,Number.MIN_VALUE);return t.forEach((t,e)=>{n[Utils.getKeys(n)[e]]&&(i.left=Math.min(Math.min(...t),i.left),i.right=Math.max(Math.max(...t),i.right))}),i.left===Number.MAX_VALUE&&(i.left=Math.min(...t[0])),i.right===Number.MIN_VALUE&&(i.right=Math.max(...t[0])),i}static getLimits(t,n,i){const e=new Boundaries(Number.MIN_VALUE,Math.max(...t),Number.MAX_VALUE,Math.min(...t));return n.forEach((t,n)=>{i[Utils.getKeys(i)[n]]&&(e.bottom=Math.min(Math.min(...t),e.bottom),e.top=Math.max(Math.max(...t),e.top))}),e.bottom===Number.MAX_VALUE&&(e.bottom=Math.min(...n[0])),e.top===Number.MIN_VALUE&&(e.top=Math.max(...n[0])),e}static calculateCanvasBoundaries(t,n){return new Boundaries(t.height-n.top,t.width-n.right,n.bottom,n.left)}static drawChartLine(t,n,i,e,a,h){t.lineWidth=a,t.lineCap="round",t.strokeStyle=e,t.beginPath(),n.forEach((n,e)=>{i.length>e&&t.lineTo(n,i[e])}),t.stroke(),isNullOrUndefined(h)||(t.beginPath(),t.fillStyle="#FFFFFF",t.arc(n[h],i[h],5,0,2*Math.PI),t.fill(),t.arc(n[h],i[h],5,0,2*Math.PI),t.stroke())}static formatDate(t){const n=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],i=t.getDate();return n[t.getMonth()]+" "+i}static getScale(t,n){return Math.abs(n.right-n.left)/Math.abs(t.right-t.left)}static getKeys(t){return Object.keys(t)}static getInterval(t,n){const i=(t.right-t.left)/Math.pow(10,6);t.right+=i,t.left-=i;const e=(t.right-t.left)/(n-1),a=[1,1.5,2,2.5,5,7.5,10],h=Math.pow(10,-Math.floor(Math.log10(Math.abs(e)))),s=e*h,r=a.find(t=>t>=s),o=Number.parseInt((r/h).toFixed()),u=Math.ceil(t.right/o)*o,l=Math.floor(t.left/o)*o;return new Interval(l,u,o)}}class TelegramChart{constructor(){this.canvasContext=null,this.canvas=null,this._width=1e3,this._height=500,this._needInit=!1,this._bigCanvasMargin=new Boundaries(20,0,40,0),this._drawingBoundaries=new Boundaries(0,0,0,0),this.initCanvas("constructor")}initCanvas(){this._needInit=!1,this.canvas=document.getElementById("chartCanvas"),this.canvas.width=this._width,this.canvas.height=this._height,this.canvasContext=this.canvas.getContext("2d"),this.canvasContext.transform(1,0,0,-1,0,this.canvas.height),this._drawingBoundaries=Utils.calculateCanvasBoundaries(this.canvas,this._bigCanvasMargin),this.drawHorizontalLines(new Interval(0,100,10))}drawHorizontalLines(t){this.canvasContext.beginPath(),this.canvasContext.strokeStyle="rgba(223, 230, 235)",this.canvasContext.lineWidth=1;let n=0;for(;n<=t.right-t.left&&t.step>0;){const i=n+this._drawingBoundaries.bottom;this.canvasContext.moveTo(this._drawingBoundaries.left,i),this.canvasContext.lineTo(this._drawingBoundaries.right,i),n+=t.step}this.canvasContext.stroke()}}new TelegramChart;